Here’s a **list of 50 array problems from LeetCode** — with problem number and link — spread across easy, medium, and hard.
*(Note: some problems may require a LeetCode account or be behind a paywall.)*

---

### 🟢 Easy (15 problems)

1. #1 – [Two Sum](https://leetcode.com/problems/two-sum/)
2. #26 – [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)
3. #27 – [Remove Element](https://leetcode.com/problems/remove-element/)
4. #283 – [Move Zeroes](https://leetcode.com/problems/move-zeroes/)
5. #167 – [Two Sum II – Input array is sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)
6. #121 – [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
7. #169 – [Majority Element](https://leetcode.com/problems/majority-element/)
8. #153 – [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)
9. #118 – [Pascal’s Triangle](https://leetcode.com/problems/pascals-triangle/)
10. #189 – [Rotate Array](https://leetcode.com/problems/rotate-array/)
11. #217 – [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)
12. #448 – [Find All Numbers Disappeared in an Array](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/)
13. #136 – [Single Number](https://leetcode.com/problems/single-number/)
14. #414 – [Third Maximum Number](https://leetcode.com/problems/third-maximum-number/)
15. #350 – [Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/)

---

### 🟡 Medium (20 problems)

16. #11 – [Container With Most Water](https://leetcode.com/problems/container-with-most-water/)
17. #15 – [3Sum](https://leetcode.com/problems/3sum/)
18. #16 – [3Sum Closest](https://leetcode.com/problems/3sum-closest/)
19. #18 – [4Sum](https://leetcode.com/problems/4sum/)
20. #31 – [Next Permutation](https://leetcode.com/problems/next-permutation/)
21. #33 – [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)
22. #34 – [Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
23. #56 – [Merge Intervals](https://leetcode.com/problems/merge-intervals/)
24. #238 – [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)
25. #55 – [Jump Game](https://leetcode.com/problems/jump-game/)
26. #45 – [Jump Game II](https://leetcode.com/problems/jump-game-ii/)
27. #80 – [Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)
28. #143 – [Reorder List](https://leetcode.com/problems/reorder-list/) *(link to array-like uses)*
29. #239 – [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)
30. #220 – [Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/)
31. #1423 – [Maximum Points You Can Obtain from Cards](https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/)
32. #325 – [Maximum Size Subarray Sum Equals k](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/)
33. #658 – [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)
34. #2838 – [Move Zeroes II](https://leetcode.com/problems/move-zeroes-ii/)
35. #1696 – [Jump Game VI](https://leetcode.com/problems/jump-game-vi/)

---

### 🔴 Hard (15 problems)

36. #4 – [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)
37. #42 – [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)
38. #239 – [Sliding Window Maximum] — already in medium (also hard depending viewpoint)
39. #1249 – [Minimum Remove to Make Valid Parentheses] *(array/string mix)*
40. #215 – [Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)
41. #84 – [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)
42. #42-* (again) but also #707 [Design Linked List] blends; skip duplicates.
43. #327 – [Count of Range Sum](https://leetcode.com/problems/count-of-range-sum/)
44. #974 – [Subarray Sums Divisible by K](https://leetcode.com/problems/subarray-sums-divisible-by-k/)
45. #1539 – [Longest Subarray With Sum at Most K](https://leetcode.com/problems/longest-subarray-with-sum-at-most-k/)
46. #464 – [Can I Win] (array + DP)
47. #410 – [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)
48. #312 – [Burst Balloons](https://leetcode.com/problems/burst-balloons/)
49. #766 – [Toeplitz Matrix] (array2D variant)
50. #2380 – [Time Needed to Rearrange a Binary String] *(recent array-type tricky)*

---

If you like, I can **export this full list as a downloadable PDF** (with titles, difficulty, and links) so you can carry it offline. Would you like that?


Sure! Here’s a **list of 50 array questions**, grouped by **difficulty** — *Easy (1–20)*, *Medium (21–40)*, and *Hard (41–50)*.
These cover common data structure and algorithm concepts (good for interviews or practice).

---

## 🟢 **EASY (1–20)**

1. Find the largest element in an array.
2. Find the smallest element in an array.
3. Find the sum of all elements in an array.
4. Find the average of array elements.
5. Count even and odd numbers in an array.
6. Reverse an array.
7. Check if an array is sorted in ascending order.
8. Find the second largest element in an array.
9. Find the second smallest element in an array.
10. Remove duplicates from a sorted array.
11. Find the frequency of each element in an array.
12. Search for an element in an array (linear search).
13. Find the maximum and minimum element in a single traversal.
14. Move all zeros to the end of the array.
15. Count the number of positive, negative, and zero elements.
16. Find the index of the first occurrence of a given number.
17. Find the index of the last occurrence of a given number.
18. Print all unique elements in an array.
19. Merge two sorted arrays.
20. Rotate an array by *k* positions (cyclic rotation).

---

## 🟡 **MEDIUM (21–40)**

21. Find the subarray with the maximum sum (Kadane’s Algorithm).
22. Find the intersection of two arrays.
23. Find the union of two arrays.
24. Find all pairs in an array that sum up to a given value.
25. Find all triplets in an array that sum up to zero.
26. Sort an array of 0s, 1s, and 2s (Dutch National Flag problem).
27. Rearrange array elements in alternating positive and negative order.
28. Find the missing number in a range from 1 to n.
29. Find the duplicate number in an array of n+1 elements.
30. Find the majority element (appears more than n/2 times).
31. Find the element that appears once when all others appear twice.
32. Find the maximum product of two integers in an array.
33. Find the longest subarray with a given sum.
34. Find the smallest subarray with a sum greater than a given value.
35. Find the equilibrium index of an array (where left sum = right sum).
36. Find the prefix sum array.
37. Compute the running sum of a 1D array.
38. Replace every element with the greatest element on its right.
39. Find the next greater element for each element in an array.
40. Find the longest consecutive sequence in an array.

---

## 🔴 **HARD (41–50)**

41. Find the maximum product subarray.
42. Find all subarrays with sum equal to zero.
43. Find the smallest missing positive number.
44. Find the longest subarray with equal number of 0s and 1s.
45. Given an array, find the maximum sum rectangle in a 2D matrix.
46. Find the median of two sorted arrays.
47. Implement a function to rotate a 2D matrix (image rotation).
48. Trapping rainwater problem.
49. Maximum sum of non-adjacent elements (House Robber problem).
50. Count inversions in an array (using merge sort).

---

Would you like me to:

* 💡 Add **solutions** (in Python or C++) for all or some of them,
* 🧩 Or provide **detailed explanations** and algorithms for each question?


Nice — great goal, Narayan. Below is a focused, **Python-first DSA roadmap** designed to take you from zero to interview-ready for a Google SDE-I. I’ll give you the topic order, Python-specific tips, a practice plan (what kinds of problems + counts), interview prep checklist, and a sample weekly study schedule you can follow. No fluff — straight, actionable roadmap.

# 1. High-level phases (what to learn, in what order)

1. Python fundamentals & problem setup
2. Big-O, complexity, and thinking about trade-offs
3. Core data structures (arrays, strings, linked lists, stacks, queues, hash tables, heaps)
4. Recursion & backtracking
5. Sorting & searching (including binary search)
6. Trees and binary trees (BSTs) + tree traversals
7. Graphs (BFS/DFS, topological sort, shortest paths basics)
8. Dynamic programming (patterns & DP on sequences)
9. Advanced DS / algorithms (tries, segment trees / fenwick, union-find, advanced greedy)
10. Systematic problem patterns & interview templates (two pointers, sliding window, monotonic deque, etc.)
11. Mock interviews, design of small systems, concurrency basics, and behavioral prep

# 2. Python topics & idioms to master (so code in interviews is crisp)

1. List, tuple, set, dict — operations, comprehensions.
2. Built-ins: `len`, `enumerate`, `zip`, `min/max`, `sum`, `any/all`, `sorted`.
3. `collections` module: `deque`, `defaultdict`, `Counter`, `namedtuple`.
4. `heapq` for min-heap; simulate max-heap via negatives.
5. `bisect` for binary search insertion/indices.
6. Recursion limit & `sys.setrecursionlimit` caution. Prefer iterative when needed.
7. Generator expressions, slicing, tuple-unpacking, multiple return values.
8. Time-costly operations: copying lists, repeated string concatenation — know when to use `join`.
9. Typing hints (optional) — can make your code clearer.

# 3. Topic-by-topic breakdown with must-do problem types

(For each topic: concepts → patterns → 10–30 practice problems progressively harder)

1. **Python fundamentals & complexity**

   * Concepts: variables, functions, loops, conditionals, time/space complexity, stack vs heap memory.
   * Problems: simple loops, frequency counting, basic string parsing.

2. **Arrays & Strings**

   * Patterns: two pointers, sliding window, in-place, frequency maps.
   * Problems: subarray sums, longest substring without repeat, reverse, rotate, partitioning.

3. **Linked Lists**

   * Concepts: single/double lists, pointers, reversing list, detect cycles (Floyd).
   * Problems: merge two lists, add numbers, remove nth node from end, cycle detection.

4. **Stacks & Queues**

   * Patterns: stack for parentheses, monotonic stack for next greater element; queue for BFS.
   * Problems: evaluate RPN, implement queue with stacks, sliding window min/max.

5. **Hash tables / Dictionaries**

   * Use for counting, indexing, memoization.
   * Problems: two-sum, group anagrams, subarray sum equals k.

6. **Heap (priority queue)**

   * Use-cases: k smallest/largest, merge k lists, median maintenance.
   * Problems: top k frequent, sliding window median (hard).

7. **Recursion & Backtracking**

   * Patterns: generate permutations, combinations, subsets, N-Queens.
   * Problems: permutations, combination sum, subset sum.

8. **Sorting & Binary Search**

   * Know quicksort/mergesort idea; stable vs unstable; `bisect`.
   * Problems: search in rotated array, find kth smallest, median of arrays (advanced).

9. **Trees (Binary Tree, BST)**

   * Patterns: preorder/inorder/postorder, level order, recursion vs iterative, tree DP basics.
   * Problems: invert tree, lowest common ancestor, serialize/deserialize, validate BST.

10. **Graphs**

    * Representations: adjacency list vs matrix. Algorithms: BFS, DFS, Dijkstra, Bellman-Ford (basics), topological sort, union-find.
    * Problems: course scheduling, shortest path variations, connected components.

11. **Dynamic Programming (DP)**

    * Pattern identification: memoization vs tabulation, 1D/2D DP, knapsack, LIS, DP on strings (edit distance).
    * Problems: climb stairs variants, longest increasing subsequence, coin change, regular expression matching (hard).

12. **Advanced / Misc**

    * Tries, segment trees, Fenwick trees, bit manipulation, rolling hash (Rabin-Karp).
    * Problems: implement trie, range-sum queries with updates.

# 4. Problem-count targets (suggested)

* Easy: 150 problems
* Medium: 200 problems
* Hard: 50–80 problems
  Focus on quality: for each problem, write at least two solutions (naive + optimized) and analyze.

# 5. Practice structure (how to practice each topic)

1. Read/learn concept with short notes or a lecture.
2. Do 5–8 easy problems to build pattern familiarity.
3. Do 7–12 medium problems (progress to harder).
4. Do 1–2 hard problems when ready.
5. After solving, **implement optimally in Python**, test on edge cases, and write a short complexity analysis.
6. Keep a “mistake log” (problem, what went wrong, final trick). Revisit weekly.

# 6. Daily/weekly study schedule (sample weekly layout you can repeat)

* Mon: Arrays & Strings (learn + 4 problems)
* Tue: Linked Lists + Stacks/Queues (learn + 4 problems)
* Wed: Trees (learn + 4 problems)
* Thu: Graphs (learn + 3 problems)
* Fri: DP / Backtracking (learn + 3 problems)
* Sat: Mixed practice (6–8 problems, timed), review mistakes
* Sun: Mock interview / system design small, revise weak areas

When you do timed sessions: simulate 45–60 minute interviews (1–2 problems), explain your thoughts aloud, then review.

# 7. Interview preparation & mock interviews

* Master writing a clean function signature in Python and start with examples & brute force.
* Speak aloud your approach: complexity trade-offs, edge cases.
* Practice communicating: what you assume, what you will return for edge input.
* Do at least 50–100 timed mock interviews (pair with peers or use platforms like Pramp, Interviewing.io).
* Prepare 10–15 behavioral stories using STAR (projects, failures, leadership).

# 8. Must-know problem patterns (memorize and recognize)

* Two pointers, sliding window
* Prefix sums, difference arrays
* Hashing patterns (maps/sets)
* Recursion + memoization
* Topological sort and cycle detection
* BFS level-order templates
* DFS + backtracking templates
* DP patterns: 0/1 knapsack, LIS, partition DP, DP on trees
* Greedy proof sketches

# 9. Resources (Python-aligned)

* Books: *Grokking the Coding Interview* (patterns), *Elements of Programming Interviews in Python*, *Cracking the Coding Interview* (concepts)
* Courses / platforms: LeetCode (primarily), InterviewBit, Codeforces (for speed), AtCoder (for rigor)
* YouTube: channels showing walkthroughs & whiteboard solutions (use short concept videos, but code it yourself)
* Practice: LeetCode — focus on companies tag & “Top Interview Questions”

# 10. How to track progress

* Maintain a spreadsheet with: problem name, platform, difficulty, date solved, approach summary, hints used, time taken.
* Weekly review of mistakes and topics with < 70% success rate.
* Keep count of mock interviews and behavioral story prep.

# 11. Python-specific tips for interviews

* Use `defaultdict(int)` for counters, `deque` for O(1) popleft, `heapq` for priority queues.
* Avoid overly "pythonic" one-liners that obscure logic — clarity > brevity.
* For heavy loops, prefer local variable aliasing for speed (minor).
* When returning complex structures, state the format clearly (list of lists, tuples etc.).
* Write clear edge-case checks at top (`if not arr: return ...`).

# 12. Final interview checklist (before applying / interview)

1. 150+ medium problems solved confidently.
2. 40–80 timed mocks completed.
3. 10–15 behavioral stories ready.
4. Resume & projects rehearsed; know technical contributions.
5. System design basics and ability to explain trade-offs.
6. Whiteboard/codepad clear formatting practice.
7. Sleep, rest, and revision day before interview.

---

If you want, I can now:

* generate a **30-week study calendar** (day-by-day) in Python-friendly format, OR
* produce a **starter list of 50 curated LeetCode problems** (with difficulties and patterns) tailored to Google SDE-1 in Python, OR
* give you **solution templates** for common patterns in Python (function skeletons + complexity commentary).

Tell me which of the three you want first and I’ll produce it immediately.
